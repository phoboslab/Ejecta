// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// Objective-C Wrapper by Richard Moore (me@ricmoo.com), 2014.
//
// Original Clipper library by Angus Johnson (see clipper.hpp for more details).
//

#import "GMPolygon.h"
#import "GMPolygon+private.h"

#include "clipper.hpp"


// Convert between the C++ enums and our enums (maybe just do a cast?)
ClipperLib::PolyFillType convertPolygonFillType(PolygonFillType polygonFillType) {
    switch (polygonFillType) {
        case PolygonFillTypeEvenOdd:
            return ClipperLib::pftEvenOdd;
        case PolygonFillTypeNegative:
            return ClipperLib::pftNegative;
        case PolygonFillTypeNonZero:
            return ClipperLib::pftNonZero;
        case PolygonFillTypePositive:
            return ClipperLib::pftPositive;
        default:
            NSLog(@"Unknown Polygon Fill Type: %d (something bad might happen)", polygonFillType);
    }
    return ClipperLib::pftEvenOdd;
}


NSArray *convertPaths(ClipperLib::Paths paths) {
    NSMutableArray *result = [NSMutableArray arrayWithCapacity:paths.size()];
    for(ClipperLib::Paths::iterator it = paths.begin(); it != paths.end(); ++it) {
        [result addObject:[GMPolygon polygonFromPath:*it]];
    }
    return result;
}


#pragma mark - Point Data Structure

@implementation GMPoint

+ (id)pointWithX: (NSInteger)x y: (NSInteger)y {
    GMPoint *point = [[self alloc] init];
    point.x = x;
    point.y = y;
    return point;
}

- (NSString*)description {
    return [NSString stringWithFormat:@"(%ld,%ld)", self.x, self.y];
}

@end


#pragma mark - Path Wrapper

@interface GMPolygon () {
    ClipperLib::Path *_path;
}

@end


@implementation GMPolygon

+ (id)polygon {
    return [[self alloc] init];
}

+ (id)polygonFromPath:(ClipperLib::Path)path {
    return [[GMPolygon alloc] initWithPath:path];
}

- (id)init {
    self = [super init];
    if (self) {
        _path = new ClipperLib::Path();
    }
    return self;
}

- (id)initWithPath: (ClipperLib::Path)path {
    self = [super init];
    if (self) {
        _path = new ClipperLib::Path(path);
    }
    return self;
}

- (void)dealloc {
    delete _path;
}


#pragma mark - Used internally

- (ClipperLib::Path)path {
    return *_path;
}

#pragma mark -

+ (NSArray*)simplifyPolygon: (GMPolygon*)polygon {
    ClipperLib::Paths result;
    ClipperLib::SimplifyPolygon(polygon.path, result);
    return convertPaths(result);
}

+ (NSArray*)simplifyPolygon: (GMPolygon*)polygon polygonFillType: (PolygonFillType)polygonFillType {
    ClipperLib::Paths result;
    ClipperLib::SimplifyPolygon(polygon.path, result, convertPolygonFillType(polygonFillType));
    return convertPaths(result);
}

+ (NSArray*)simplifyPolygons: (NSArray*)paths {
    ClipperLib::Paths result;
    for (GMPolygon *polygon in paths) {
        result.push_back(polygon.path);
    }
    ClipperLib::SimplifyPolygons(result);
    return convertPaths(result);
}

+ (NSArray*)simplifyPolygons: (NSArray*)polygons polygonFillType: (PolygonFillType)polygonFillType {
    ClipperLib::Paths result;
    for (GMPolygon *polygon in polygons) {
        result.push_back(polygon.path);
    }
    ClipperLib::SimplifyPolygons(result, convertPolygonFillType(polygonFillType));
    return convertPaths(result);
}

+ (GMPolygon*)cleanPolygon: (GMPolygon*)polygon {
    ClipperLib::Path result;
    ClipperLib::CleanPolygon(polygon.path, result);
    return [GMPolygon polygonFromPath:result];
}

+ (GMPolygon*)cleanPolygon: (GMPolygon*)polygon distance: (double)distance {
    ClipperLib::Path result;
    ClipperLib::CleanPolygon(polygon.path, result, distance);
    return [GMPolygon polygonFromPath:result];
}

+ (NSArray*)cleanPolygons: (NSArray*)polygons {
    ClipperLib::Paths result;
    for (GMPolygon *polygon in polygons) {
        result.push_back(polygon.path);
    }
    ClipperLib::CleanPolygons(result);
    return convertPaths(result);
}

+ (NSArray*)cleanPolygons: (NSArray*)polygons distance: (double)distance {
    ClipperLib::Paths result;
    for (GMPolygon *polygon in polygons) {
        result.push_back(polygon.path);
    }
    ClipperLib::CleanPolygons(result, distance);
    return convertPaths(result);
}


#pragma mark - Query

- (double)area {
    return ClipperLib::Area(*_path);
}

- (Orientation)orientation {
    return ClipperLib::Orientation(*_path) ? OrientationClockwise: OrientationAnticlockwise;
}

- (BOOL)containsPointX:(NSInteger)x y:(NSInteger)y {
    return ClipperLib::PointInPolygon({x, y}, *_path);
}

- (BOOL)containsPoint: (GMPoint*)point {
    return ClipperLib::PointInPolygon({point.x, point.y}, *_path);
}

- (NSUInteger)count {
    return _path->size();
}

- (NSArray*)points {
    NSMutableArray *points = [NSMutableArray arrayWithCapacity:_path->size()];
    for(ClipperLib::Path::iterator it = _path->begin(); it != _path->end(); ++it) {
        ClipperLib::IntPoint point = *it;
        [points addObject:[GMPoint pointWithX:point.X y:point.Y]];
    }
    return points;
}


#pragma mark - Manipulation

- (void)addPoint:(GMPoint*)point {
    [self addPointX:point.x y:point.y];
}

- (void)addPointX:(NSInteger)x y:(NSInteger)y {
    _path->push_back({x, y});    
}

- (void)cleanPolygon {
    ClipperLib::CleanPolygon(*_path);
}

- (void)cleanPolygonDistance:(double)distance {
    ClipperLib::CleanPolygon(*_path, distance);
}

- (void)reverse {
    ClipperLib::ReversePath(*_path);
}


- (void)clear {
    _path->clear();
}


#pragma mark - Debugging

- (NSString*)description {
    return [NSString stringWithFormat:@"<Path %@>", [[self points] componentsJoinedByString:@","]];
}

@end
