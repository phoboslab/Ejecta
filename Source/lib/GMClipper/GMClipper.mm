// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// Objective-C Wrapper by Richard Moore (me@ricmoo.com), 2014.
//
// Original Clipper library by Angus Johnson (see clipper.hpp for more details).
//

#import "GMClipper.h"

#include "clipper.hpp"
#import "GMPolygon+private.h"

// Convert between the C++ enums and our enums (maybe just do a cast?)
ClipperLib::ClipType convertClipType(ClipType clipType) {
    switch (clipType) {
        case ClipTypeDifference:
            return ClipperLib::ctDifference;
        case ClipTypeIntersection:
            return ClipperLib::ctIntersection;
        case ClipTypeUnion:
            return ClipperLib::ctUnion;
        case ClipTypeXor:
            return ClipperLib::ctXor;
        default:
            NSLog(@"Unknown Clip Type: %d (something bad might happen)", clipType);
    }
    return ClipperLib::ctDifference;
}

@interface GMClipper () {
    ClipperLib::Clipper *_clipper;
}

@end

@implementation GMClipper

+ (id)clipper {
    return [[self alloc] init];
}

- (id)init {
    self = [super init];
    if (self) {
        _clipper = new ClipperLib::Clipper(0);
    }
    return self;
}

- (void)dealloc {
    delete _clipper;
}


#pragma mark - properties

- (void)setReverseSolution: (BOOL)reverseSolution {
    _clipper->ReverseSolution(reverseSolution);
}

- (BOOL)reverseSolution {
    return _clipper->ReverseSolution();
}

- (void)setStrictlySimple: (BOOL)strictlySimple {
    _clipper->StrictlySimple(strictlySimple);
}

- (BOOL)strictlySimple {
    return _clipper->StrictlySimple();
}

- (void)setPreserveCollinear: (BOOL)preserveCollinear {
    _clipper->PreserveCollinear(preserveCollinear);
}

- (BOOL)preserveCollinear {
    return _clipper->PreserveCollinear();
}

// @TODO: Test this... Is it upside-down? bottom > top? Likewise, test the orientation property of path.
- (Bounds)bounds {
    ClipperLib::IntRect rect = _clipper->GetBounds();
    return {{rect.left, rect.top}, {rect.right - rect.left, rect.bottom - rect.top}};
}


#pragma mark - Execution

- (NSArray*)executeClipType: (ClipType)clipType {
    return [self executeClipType:clipType subjectFillType:PolygonFillTypeEvenOdd clipFillType:PolygonFillTypeEvenOdd];
}

- (NSArray*)executeClipType: (ClipType)clipType subjectFillType: (PolygonFillType)subjectFillType clipFillType: (PolygonFillType)clipFillType {
    
    // Get the solution...
    ClipperLib::Paths solution;
    bool success = _clipper->Execute(convertClipType(clipType), solution, convertPolygonFillType(subjectFillType), convertPolygonFillType(clipFillType));
    if (!success) {
        return nil;
    }
    
    // Convert it into something Objective-C friendly
    NSMutableArray *result = [NSMutableArray arrayWithCapacity:solution.size()];
    for(ClipperLib::Paths::iterator it = solution.begin(); it != solution.end(); ++it) {
        GMPolygon *path = [GMPolygon polygonFromPath:*it];
        [result addObject:path];
    }
    return result;
}


#pragma mark - Manipulation

- (BOOL)addPolygon: (GMPolygon*)polygon polygonType: (ClipperLib::PolyType)polyType closed: (BOOL)closed {
    return _clipper->AddPath(polygon.path, polyType, closed);
}

- (BOOL)addPolygons: (NSArray*)polygons polygonType: (ClipperLib::PolyType)polyType closed: (BOOL)closed {
    int success = 0;
    for (GMPolygon *polygon in polygons) {
        bool added = _clipper->AddPath(polygon.path, polyType, closed);
        if (added) {
            success++;
        }
    }
    return (success > 0);
}

- (BOOL)addSubjectPolygon:(GMPolygon*)polygon {
    return [self addPolygon:polygon polygonType:ClipperLib::ptSubject closed:YES];
}

- (BOOL)addSubjectPolygons:(NSArray *)polygons {
    return [self addPolygons:polygons polygonType:ClipperLib::ptSubject closed:YES];
}

- (BOOL)addClippingPolygon:(GMPolygon*)polygon {
    return [self addPolygon:polygon polygonType:ClipperLib::ptClip closed:YES];
}

- (BOOL)addClippingPolygons:(NSArray *)polygons {
    return [self addPolygons:polygons polygonType:ClipperLib::ptClip closed:YES];
}

- (void)clear {
    _clipper->Clear();
}


@end
